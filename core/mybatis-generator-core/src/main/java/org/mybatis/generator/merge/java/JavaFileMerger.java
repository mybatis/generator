/*
 *    Copyright 2006-2026 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.mybatis.generator.merge.java;

import static org.mybatis.generator.internal.util.messages.Messages.getString;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;

import com.github.javaparser.JavaParser;
import com.github.javaparser.ParseResult;
import com.github.javaparser.Problem;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.BodyDeclaration;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.github.javaparser.printer.DefaultPrettyPrinter;
import com.github.javaparser.printer.configuration.PrinterConfiguration;
import org.jspecify.annotations.Nullable;
import org.mybatis.generator.exception.MultiMessageException;
import org.mybatis.generator.exception.ShellException;

/**
 * This class handles the task of merging changes into an existing Java file using JavaParser.
 * It supports merging by removing methods and fields that have specific Javadoc tags or annotations.
 *
 * <p>Given an existing source file and a newly generated file of the same name, the merger will:
 * <ol>
 *     <li>Parse the existing file looking for custom additions. A custom addition is defined in these ways:
 *         <ul>
 *             <li>A body element (field, method, nested class, etc.) not marked as generated - missing both a
 *                 <code>@Generated</code> annotation and an older style custom Javadoc tag.</li>
 *             <li>A body element (field, method, nested class, etc.) marked as generated by an older style custom
 *                 Javadoc tag and also containing the phrase "do_not_delete_during_merge".</li>
 *         </ul>
 *         It is important to know that the parser will only look for direct children of either the public type or the
 *         first non-public type in a source file.
 *     </li>
 *     <li>If there are no custom additions, the newly generated file is returned unmodified.</li>
 *     <li>If there are custom additions, then:
 *         <ul>
 *             <li>Add any imports present in the existing file but missing in the new file</li>
 *             <li>Remove any members in the new file that match custom additions in the existing file</li>
 *             <li>Add all custom additions from the existing file</li>
 *             <li>The merged file is formatted and returned.</li>
 *         </ul>
 *     </li>
 * </ol>
 *
 * @author Freeman (original)
 * @author Jeff Butler (refactoring and enhancements)
 */
public class JavaFileMerger {
    private final PrinterConfiguration printerConfiguration;

    public JavaFileMerger(PrinterConfiguration printerConfiguration) {
        this.printerConfiguration = printerConfiguration;
    }

    /**
     * Merge a newly generated Java file with an existing Java file.
     *
     * @param newFileContent the content of the newly generated Java file
     * @param existingFile the existing Java file
     * @param fileEncoding the file encoding for reading existing Java files
     * @return the merged source, properly formatted
     * @throws ShellException if the file cannot be merged for some reason
     */
    public String getMergedSource(String newFileContent, File existingFile,
                                         @Nullable String fileEncoding) throws ShellException {
        try {
            String existingFileContent = readFileContent(existingFile, fileEncoding);
            return getMergedSource(newFileContent, existingFileContent);
        } catch (IOException e) {
            throw new ShellException(getString("Warning.32", existingFile.getName()), e); //$NON-NLS-1$
        }
    }

    /**
     * Merge a newly generated Java file with existing Java file content.
     *
     * @param newFileContent the content of the newly generated Java file
     * @param existingFileContent the content of the existing Java file
     * @return the merged source, properly formatted
     * @throws ShellException if the file cannot be merged for some reason
     */
    public String getMergedSource(String newFileContent, String existingFileContent) throws ShellException {
        JavaParser javaParser = new JavaParser();

        ParseResults existingFileParseResults = parseAndFindMainTypeDeclaration(javaParser, existingFileContent,
                FileType.EXISTING_FILE);

        // Gather custom members from the existing file. If none, just return the new file as is
        CustomMemberGatherer customMemberGatherer = new CustomMemberGatherer(existingFileParseResults.typeDeclaration);
        if (!customMemberGatherer.hasAnyMembersToMerge()) {
            return newFileContent;
        }

        // Custom members exist, need to merge...
        ParseResults newFileParseResults = parseAndFindMainTypeDeclaration(javaParser, newFileContent,
                FileType.NEW_FILE);

        // Delete elements in the new file that match doNotDeleteMembers from the existing file
        customMemberGatherer.doNotDeleteMembers()
                .forEach(m -> deleteDuplicateMemberIfExists(newFileParseResults.typeDeclaration, m));

        // Look for custom imports in the existing file and merge into the new file
        JavaMergeUtilities
                .findCustomImports(existingFileParseResults.compilationUnit, newFileParseResults.compilationUnit)
                .forEach(newFileParseResults.compilationUnit::addImport);

        // Add custom elements from the existing file to the new file
        customMemberGatherer.allCustomMembers().forEach(newFileParseResults.typeDeclaration::addMember);

        // Return the new (merged) file
        DefaultPrettyPrinter printer = new DefaultPrettyPrinter(printerConfiguration);
        return printer.print(newFileParseResults.compilationUnit);
    }

    private ParseResults parseAndFindMainTypeDeclaration(JavaParser javaParser, String source, FileType fileType)
            throws ShellException {
        ParseResult<CompilationUnit> parseResult = javaParser.parse(source);

        // little hack to pull the result out of the lambda. This allows us to avoid "orElseThrow()" later on
        @Nullable CompilationUnit[] compilationUnits = new CompilationUnit [1];
        parseResult.ifSuccessful(cu -> compilationUnits[0] = cu);

        if (compilationUnits[0] == null) {
            var mme = new MultiMessageException(parseResult.getProblems().stream().map(Problem::toString).toList());
            throw new ShellException(getString("RuntimeError.28", fileType.toString()), mme); //$NON-NLS-1$
        }

        return new ParseResults(compilationUnits[0], findMainTypeDeclaration(compilationUnits[0], fileType));
    }

    private void deleteDuplicateMemberIfExists(TypeDeclaration<?> newTypeDeclaration,
                                                      BodyDeclaration<?> member) {
        newTypeDeclaration.getMembers().stream()
                .filter(td -> JavaMergeUtilities.membersMatch(td, member))
                .findFirst()
                .ifPresent(newTypeDeclaration::remove);
    }

    private TypeDeclaration<?> findMainTypeDeclaration(CompilationUnit compilationUnit, FileType fileType)
            throws ShellException {
        // Return the first public type declaration, or the first type declaration if no public one exists
        TypeDeclaration<?> firstType = null;
        for (TypeDeclaration<?> typeDeclaration : compilationUnit.getTypes()) {
            if (firstType == null) {
                firstType = typeDeclaration;
            }
            if (typeDeclaration.isPublic()) {
                return typeDeclaration;
            }
        }
        if (firstType == null) {
            throw new ShellException(getString("RuntimeError.29", fileType.toString())); //$NON-NLS-1$
        }
        return firstType;
    }

    private String readFileContent(File file, @Nullable String fileEncoding) throws IOException {
        if (fileEncoding != null) {
            return Files.readString(file.toPath(), Charset.forName(fileEncoding));
        } else {
            return Files.readString(file.toPath(), StandardCharsets.UTF_8);
        }
    }

    private record ParseResults(CompilationUnit compilationUnit, TypeDeclaration<?> typeDeclaration) {}

    private enum FileType {
        NEW_FILE("new Java file"), //$NON-NLS-1$
        EXISTING_FILE("existing Java file"); //$NON-NLS-1$

        private final String displayText;

        FileType(String displayText) {
            this.displayText = displayText;
        }

        @Override
        public String toString() {
            return displayText;
        }
    }
}
